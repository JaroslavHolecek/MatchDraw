/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Competition/MD_Competition_base_classes.js":
/*!********************************************************!*\
  !*** ./src/Competition/MD_Competition_base_classes.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { NotOverridenFunction, NotSupportedAttributeValue } = __webpack_require__(/*! ../Core/MD_Errors */ \"./src/Core/MD_Errors.js\");\n\n/**\n * Basic class for tournament participant\n * -> extend it as you need\n */\nclass MD_Participant{\n    /**\n     * Constructor of individual participant\n     * @param {Int} id id of participant within MactchDraw \n     * @param {string} name string representation of participant\n     */\n    constructor(id, name){\n        this.md_id = id;\n        this.md_name = name;\n    }\n\n    toJSON(){\n        return {\n            md_id: this.md_id,\n            md_name: this.md_name,\n        };\n    }\n\n    toString(){\n        return `(${this.md_id}) ${this.md_name}`;\n    }\n}\n\n\n/**\n * Basic class for storing individual match\n * Each match has its participants and score\n * Extend class for adding another info like duration, place, start_time etc.\n */\nclass MD_Match{\n    /**\n     * Constructor of match\n     * @param {Int} id id of match within MatchDraw\n     * @param {Array[MD_Participant]} participants list of participants in match\n     * @param {*} score representation score (like score) of match\n     *                   Depends on competition type can has various form\n     */\n    constructor(id, participants, score=null){\n        this.md_id = id;\n        this.participants = participants;\n        this.score = score;\n    }\n\n    toJSON(){\n        return {\n            md_id: this.md_id,\n            participants_md_ids: this.participants.map(participant => participant.md_id),\n            score: this.score,\n        };\n    }\n\n    toString(){\n        return `Match ${this.md_id}:\\n\\tParticipants: ${this.get_all_participants_string()}\\n\\tScore: ${this.score}`;\n    }\n\n    get_participants_MDids(){\n        return this.participants.map(participant => participant.md_id);\n    }\n\n    get_participants_names(){\n        return this.participants.map(participant => participant.md_name);\n    }\n\n    get_all_participants_string(){\n        return this.participants.map(participant => `${participant.md_name} (${participant.md_id})`).join(\" x \");\n    }\n}\n\n/**\n * Basic class that holds connection between participant and overall result\n */\nclass MD_Result{\n    /**\n     * Constructor of Result object\n     * @param {MD_Participant} participant participant to whome result belongs\n     * @param {Object} result object with various members\n     *                        (like points, given score, gained score, batch, etc. ) \n     */\n    constructor(participant, result){\n        this.participant = participant;\n        this.result = result;\n    }\n\n    onlyResultToString() {\n        let result_str = '';\n        for (let key in this.result) {\n            result_str += `${key}: ${this.result[key]}, `;\n        }\n        // Remove the trailing comma and space\n        result_str = result_str.slice(0, -2);\n        return result_str;\n    }\n\n    toString(){\n        return `${this.participant} ${this.onlyResultToString()}`;\n    }\n}\n\n/**\n * Basic class for tournament.\n * Tournament consist of participants and individual matches\n * Extend class for adding another info like place, date etc.\n */\nclass MD_Tournament{\n    constructor(md_id, name, result_template, results_sort_function, participants=[]){\n        this.md_id = md_id;\n        this.name = name;\n        this.matches = [];\n        this.results = [];\n        this.result_template = result_template;\n        this.sortResultsFce = results_sort_function;\n\n        if(participants.length > 0) {this.initAllParticipants(participants);}\n    }\n\n    /* ***************************** */\n    /* *** TO OVERRIDE FUNCTIONS *** */\n    /* ***************************** */\n\n    /**\n     * Count match (probably its score) to result form. This result form can be added to result of participant\n     * @param {MD_Match} match that will be converted to result form \n     * @return {Array(MD_Result)} array of MD_Results - one for each participant in match \n     */\n    count_matchToResult(match){\n        /* let index_in_score = match.participants.find(p => p === result.participant); */\n        /* if (index_in_score < 0) {throw new Error(`Participant ${participant} not found in its matches - some deep Error happen...`);} */\n        throw new NotOverridenFunction('count_matchToResult', 'MD_Tournament');\n\n    }\n\n    draw(must_play_participants=[], prefer_different_club=true){\n        throw new NotOverridenFunction('draw', 'MD_Tournament');\n    }\n\n\n    /* ******************************* */\n    /* * TO OVERRIDE FUNCTIONS - END * */\n    /* ******************************* */\n    /* Of course, you can override whatever you want...\n        above functions HAVE TO be overriden -> filled\n     */\n    \n    arrangeMatches(){\n        console.log(\"In base-class function arrangeMatches() are matches left in same order they were added.\");\n    }\n\n    addParticipant(participant){\n        this.results.push(new MD_Result(participant, structuredClone(this.result_template.template)));\n    }\n\n    initAllParticipants(participants, clear_current=false){\n        if (clear_current) {this.results = [];}\n        participants.forEach(participant => {\n            this.addParticipant(participant);\n        });\n    }\n\n    getResult_byParticipantMDid(md_id){\n        return this.results.find(r => r.participant.md_id === md_id);\n    }\n\n    get_participants(){\n        return this.results.map(result => result.participant);\n    }\n\n    get_participants_MDids(){\n        return this.results.map(result => result.participant.md_id);\n    }\n\n    get_participants_names(){\n        return this.results.map(result => result.participant.name);\n    }\n\n    addMatch(match){\n        this.matches.push(match);\n    }\n\n    getMatch_byMDid(md_id){\n        return this.matches.find(m => m.md_id === md_id);\n    }\n\n    getMatches_playedOut(){\n        return this.matches.filter(match => match.score !== null);\n    }\n\n    getMatches_unplayed(){\n        return this.matches.filter(match => match.score === null);\n    }\n\n    getNextUnplayedMatch(){\n        return this.matches.find(m => m.score === null);\n    }\n\n    getMatches_ofParticipant(participant){\n        return this.matches.filter(match => match.participants.includes(participant));\n    }\n\n    setScoreOfMatch(match, score){\n        if(match instanceof Int){\n            match = this.getMatch_byMDid(match);\n        }        \n        match.score = score;\n    }\n\n\n    /**\n     * Add result of match to tournament results of individual participants of match\n     * Use count_matchToResult() function that has to be overriden by your tournament rule\n     * @param {*} match match to be accounted\n     */\n    add_matchToResults(match){\n        if (match.score === null){ throw new NotSupportedAttributeValue(\"match.score\", match.score, message = \"Only played/filled match can be accounted\");}\n        this.count_matchToResult(match).forEach(match_result => {\n            this.result_template.add(\n                this.results.find(r => r.participant === match_result.participant).result,\n                match_result.result\n                );\n        });\n    }\n\n    /**\n     * Reset all participants result to default (template) value an fill them by all played matches from tournament list of matches\n     */\n    recount_allResults(){\n        this.results.forEach(result => {\n            result.result = structuredClone(this.result_template.template);\n        });\n        this.getMatches_playedOut.forEach(match => {          \n            this.add_matchToResults(match, result);\n        });\n    }\n\n    computeResults_all(){\n        this.participants.forEach(participant => {\n            this.computeResult(participant);\n        });\n    }    \n\n    sortResults(){\n        this.results.sort((a,b) => {\n            return this.sortResultsFce(a.result, b.result);\n        });\n    }\n\n    showCountedOrder(){\n        console.log(\"Final order:\");\n        let order = 1;\n        this.results.forEach(result => {\n            console.log(`\\t${order}# ${result}`);\n            order++;\n        });\n    }\n}\n\nmodule.exports = { MD_Participant, MD_Match, MD_Result, MD_Tournament };\n\n\n\n\n//# sourceURL=webpack://matchdraw/./src/Competition/MD_Competition_base_classes.js?");

/***/ }),

/***/ "./src/Competition/MD_Options.js":
/*!***************************************!*\
  !*** ./src/Competition/MD_Options.js ***!
  \***************************************/
/***/ ((module) => {

eval("\n/**\n * template is template (like init) of result of participant - intended over whole turnament\n * sort_functions is rule how to compare two results in form of template. Will be used in sort() function\n */\nconst RESULT_TEMPLATES = {\n    POINTS:\n    {   template: {points: 0},\n        add(to, from){\n            to.points += from.points;\n        },\n        toString(){\n            return `${this.points}`;\n        },\n        sort_functions: {\n            /**\n             * More points -> better placement\n             */\n            DESC(r1, r2){\n                return r2.points - r1.points;\n            }\n        }        \n    },\n    \n    SETS_POINTS_GIVE_GET:\n    {   template: {sets: 0, points_give: 0, points_get: 0},\n        add(to, from){\n            to.sets += from.sets;\n            to.points_give += from.points_give;\n            to.points_get += from.points_get;\n        },\n        sort_functions: {\n            /**\n             * 1) More sets -> better placement\n             * 2) Higher points_give - points_get -> better placement\n             * TODO: Winner of mutual match - list througt matches for r1.participant\n             * TODO: random\n             */\n            SETS_POINTS_DIFF(r1, r2){\n                let res = r2.sets - r1.sets;\n                if (res !== 0){ return res; }\n                \n                return (r2.points_give - r2.points_get) -\n                    ((r1.points_give - r1.points_get));                \n            }\n        }\n    },\n}\n\nmodule.exports = { RESULT_TEMPLATES };\n\n//# sourceURL=webpack://matchdraw/./src/Competition/MD_Options.js?");

/***/ }),

/***/ "./src/Competition/MD_Swiss_Radon.js":
/*!*******************************************!*\
  !*** ./src/Competition/MD_Swiss_Radon.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {\n    indexesOfMaxInArray,\n    weightsGenerator_Edmonds,\n    POLICY_EDMOND_WEIGHTS,\n} = __webpack_require__(/*! ../Core/MD_Helpers */ \"./src/Core/MD_Helpers.js\");\n\n\nconst {\n    MD_Tournament,\n    MD_Participant,\n    MD_Result, \n    MD_Match,\n} = __webpack_require__(/*! ./MD_Competition_base_classes */ \"./src/Competition/MD_Competition_base_classes.js\");\n\nconst {\n    RESULT_TEMPLATES,   \n} = __webpack_require__(/*! ./MD_Options */ \"./src/Competition/MD_Options.js\");\n\nconst { one4each } = __webpack_require__(/*! ../Core/MD_MatchGenerator */ \"./src/Core/MD_MatchGenerator.js\");\n\nclass Participant_Radon extends MD_Participant{\n    constructor(id, name, club, birth_year){\n        super(id, name);\n        this.club = club;\n        this.birth_year = birth_year;\n        this.tmp_id; /* temporary id - helper for draw / generating weights */\n        this.number_of_played_matches = 0;\n    }\n\n    toJSON(){\n        let json = super.toJSON();\n        json.birth_year = this.birth_year;\n        return json;\n    }\n\n    toString(){\n        return `${super.toString()}\\t${this.birth_year}\\t${this.club}`;\n    }\n\n    toString_full(){\n        return `${this.birth_year}, ${this.club}, ${super.toString()}`;\n    }\n}\n\nclass Tournament_Swiss_Radon extends MD_Tournament{\n    constructor(id, name, date, in_year_number, participants){\n        super(id, name,\n            RESULT_TEMPLATES.SETS_POINTS_GIVE_GET,\n            RESULT_TEMPLATES.SETS_POINTS_GIVE_GET.sort_functions.SETS_POINTS_DIFF,\n            participants );\n        this.date = date;\n        this.in_year_number = in_year_number;\n        this.number_of_played_round = 0;\n    }\n\n    count_matchToResult(match){\n        /* score = [ [15,6] , [10,15] ] for example */ \n        let allResults = [];\n        match.participants.forEach((participant, index) => {\n            let res = new MD_Result(participant, structuredClone(this.result_template.template));\n            match.score.forEach(set => {\n                res.result.points_give += set[index];\n                res.result.points_get += set.reduce((a, b) => a + b, 0) - set[index]; /* sum of all points minus given points - in case not only two participants play each other*/\n                if (indexesOfMaxInArray(set).includes(index)) {\n                    res.result.sets += 1;\n                }else{\n                    res.result.sets -= 1; /* compute difference of given and get sets if more faire for players that were odd and play less matches */\n                }\n            });\n            allResults.push(res);\n        });\n        return allResults;\n    }\n\n    /* generate weights accounting actual stored order of results (participants) in Tournament\n        call sortResults() before this function if you want generate weights for sorted participants\n    */\n    generate_weights(must_play_participants=[], prefer_different_club=true){\n        \n        /* set tmp_id as index in array of results/participants */\n        this.results.forEach((result, index) => {\n            result.participant.tmp_id = index;\n        });\n\n        /* init */\n        let weights = weightsGenerator_Edmonds(this.results.length, POLICY_EDMOND_WEIGHTS.E2E_SORTED_LINEAR);\n        \n        /* remove edges of already drawen match -> do not repeat already played matches */\n        this.matches.forEach(match => {\n            let participants_tmp_id = match.participants.map(p=> p.tmp_id);\n            let edge_index = weights.findIndex(w =>\n                participants_tmp_id.includes(w[0]) && participants_tmp_id.includes(w[1])\n                )\n            if (edge_index !== -1){ /* match really found */\n                weights.splice(edge_index, 1);\n            }\n            \n        });\n\n        /* increase value of edges of must_play_participants -> no pause second time */\n        if(must_play_participants.length > 0){\n            let increasing_value = this.results.length; /* higher weight than any other */\n            let must_play_participants_tmp_ids = must_play_participants.map(p => p.tmp_id);\n            weights.forEach(edge => {\n                if(must_play_participants_tmp_ids.includes(edge[0]) || must_play_participants_tmp_ids.includes(edge[1]) ){\n                    edge[2] += increasing_value;\n                }\n            });\n        }\n\n        /* decrease value of edges between participant from same club */\n        if (prefer_different_club){\n            let decreasing_value = 3;\n            weights.forEach(edge => {\n                if(this.results[edge[0]].participant.club === this.results[edge[1]].participant.club){\n                    edge[2] = Math.max(edge[2]-decreasing_value, 0); /* no negative weights */\n                }\n            });\n        }\n\n        return weights;\n    }\n\n    generate_weights_compensatory(participants, prefer_different_club=true){\n        \n        /* set tmp_id as index in array of results/participants */\n        this.results.forEach(result => {\n            result.participant.tmp_id = -1; /* remove old values */\n        });\n        participants.forEach((participant, index) => {\n            participant.tmp_id = index; /* set actual values */\n        });\n\n        /* init */\n        let weights = weightsGenerator_Edmonds(participants.length, POLICY_EDMOND_WEIGHTS.E2E_SORTED_LINEAR);\n        \n        /* remove edges of already drawen match -> do not repeat already played matches */\n        this.matches.forEach(match => {\n            let participants_tmp_id = match.participants.map(p=> p.tmp_id);\n            let edge_index = weights.findIndex(w =>\n                participants_tmp_id.includes(w[0]) && participants_tmp_id.includes(w[1])\n                )\n            if (edge_index !== -1){ /* match really found */\n                weights.splice(edge_index, 1);\n            }\n            \n        });\n\n        /* decrease value of edges between participant from same club */\n        if (prefer_different_club){\n            let decreasing_value = 3;\n            weights.forEach(edge => {\n                if(participants[edge[0]].club === participants[edge[1]].club){\n                    edge[2] = Math.max(edge[2]-decreasing_value, 0); /* no negative weights */\n                }\n            });\n        }\n\n        return weights;\n    }\n\n    draw(must_play_participants=[], prefer_different_club=true, compensatory_round=false){\n        this.sortResults();\n\n        let participants_to_draw, weights;\n        if(compensatory_round){\n            participants_to_draw = must_play_participants;\n            weights = this.generate_weights_compensatory(participants_to_draw, prefer_different_club);\n        }else{\n            participants_to_draw = this.results.map(r => r.participant); /* all participants */\n            weights = this.generate_weights(must_play_participants, prefer_different_club);\n        }\n\n        let {matches, singletons} = one4each(participants_to_draw, weights);\n                     \n        /* every draw match add to tournament matches */\n        let first_draw_match_id = this.matches.length;\n        let draw_matches = [];\n        matches.forEach((draw_match, draw_id) => {\n            draw_matches.push(new MD_Match(first_draw_match_id+draw_id, draw_match));\n        });\n        this.matches.push(...draw_matches);\n\n        return {draw_singletons: singletons, draw_matches: draw_matches};\n    }\n\n    draw_compensatory(participants=[], prefer_different_club=true){\n        return this.draw(participants, prefer_different_club, true);\n    }\n}\n\nmodule.exports = { Participant_Radon, Tournament_Swiss_Radon };\n\n//# sourceURL=webpack://matchdraw/./src/Competition/MD_Swiss_Radon.js?");

/***/ }),

/***/ "./src/Core/MD_Algorithms.js":
/*!***********************************!*\
  !*** ./src/Core/MD_Algorithms.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Combinations C(n,k) n choose k\n * @param {int} n \n * @param {int} k \n * @returns {Array[Array]}Array of all combinations (Arrays)  \n */\nfunction combinations(n, k = 2) {\n    const all_combinations = [];\n\n    // Initialize the combination with the first K elements\n    const currentCombination = [];\n    for (let i = 0; i < k; i++) {\n        currentCombination.push(i);\n    }\n    all_combinations.push([...currentCombination]);\n\n    // Generate next combinations until exhausted\n    while (true) {\n        let i = k - 1;\n        // Find the rightmost element that can be incremented\n        while (i >= 0 && currentCombination[i] === n - k + i) {\n            i--;\n        }\n        if (i === -1) {\n            // All combinations have been generated\n            break;\n        }\n        currentCombination[i]++;\n        // Update the remaining elements\n        for (let j = i + 1; j < k; j++) {\n            currentCombination[j] = currentCombination[j - 1] + 1;\n        }\n        all_combinations.push([...currentCombination]);\n    }\n\n    return all_combinations;\n}\n\n/**\n * Maximum weight matching https://en.wikipedia.org/wiki/Maximum_weight_matching\n * Currently use Edmonds algorithm.\n * @param {Array[NumberArray[3]]} edges Array of edges in format [node_from, node_to, weight], node_from and node_to are indexes (starting from 0) of nodes, weight is wight of edge between this nodes \n * @param {Boolean} maximumMatches if True (default), maximum possible count of edges (matches) has prirority over maximum sum of weigts \n * @returns {Object} object.matched Array[IntArray[2]] list of doubles, indexes of node_from and node_to of selected edges; object.nonmatched IntArray list of non-matched nodes (its indexes)\n * \n */\nfunction maxWeightMatching(edges, maximumMatches=true){\n    const { blossom } = __webpack_require__(/*! ./Retrieved/EdmondsBlossom.js */ \"./src/Core/Retrieved/EdmondsBlossom.js\");\n    const result = blossom(edges, maximumMatches);\n    var matched = [];\n    var nonmatched = [];\n    for (let i_from = 0; i_from < result.length; i_from++) {\n        const to = result[i_from];\n        if(to === -1){nonmatched.push(i_from);}\n        else if (i_from < to){\n            matched.push([i_from, to]);\n        }\n    }\n\n    return {\n        matched_edges: matched,\n        nonmatched_nodes: nonmatched,\n    };\n}\n\nmodule.exports = { combinations, maxWeightMatching };\n\n\n//# sourceURL=webpack://matchdraw/./src/Core/MD_Algorithms.js?");

/***/ }),

/***/ "./src/Core/MD_Errors.js":
/*!*******************************!*\
  !*** ./src/Core/MD_Errors.js ***!
  \*******************************/
/***/ ((module) => {

eval("class NotSupportedAttributeValue extends Error{\n    constructor(attr_name, attr_value, message = \"\", ...args) {\n        super(message, ...args);\n        this.name = \"NotSupportedAttributeValue\";\n        this.message = message + `Not support value ${attr_value} for ${attr_name}`;\n    } \n}\n\nclass NotMatchArguments extends Error{\n    constructor(attr1_name, attr1_value, attr2_name, attr2_value, message = \"\", ...args) {\n        super(message, ...args);\n        this.name = \"NotMatchArguments\";\n        this.message = message + `Atributes ${attr1_name} and ${attr2_name} do not match. Values: ${attr1_value} and ${attr2_value}`;\n    } \n}\n\nclass NotOverridenFunction extends Error{\n    constructor(function_name, base_class_name, message = \"\", ...args) {\n        super(message, ...args);\n        this.name = \"NotOverridenFunction\";\n        this.message = message + `Function ${function_name} from ${base_class_name} must be overriden - let it know to developer`;\n    } \n}\n\nmodule.exports = {\n    NotSupportedAttributeValue,\n    NotMatchArguments,\n    NotOverridenFunction\n};\n\n//# sourceURL=webpack://matchdraw/./src/Core/MD_Errors.js?");

/***/ }),

/***/ "./src/Core/MD_Helpers.js":
/*!********************************!*\
  !*** ./src/Core/MD_Helpers.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { combinations } = __webpack_require__(/*! ./MD_Algorithms */ \"./src/Core/MD_Algorithms.js\");\nconst { NotSupportedAttributeValue, NotMatchArguments } = __webpack_require__(/*! ./MD_Errors */ \"./src/Core/MD_Errors.js\");\n\n/**\n * Generate two-dimensional array \n * @param {int} i - first (outter) dimension\n * @param {int} j - secon (inner) dimension \n * @returns Array[ i*Array[j] ]\n */\nfunction ArrayTwodim(i, j) {\n    return Array.from(Array(i), () => new Array(j));\n}\n\nfunction SetRange(max){\n    let all =  new Set();\n    for (let index = 0; index < max; index++) {\n        all.add(index);        \n    }\n    return all;\n}\n\nconst POLICY_EDMOND_WEIGHTS = {\n    E2E_EQUAL: 0, /* Every to every, each edge has same weights === 1 */\n    E2E_SORTED_LINEAR: 1, /* Every to every, weight is linear inverse of distance between indexes (max_distance - distance + 1) */\n    E2E_SORTED_FRACTIONAL_LINEAR: 2, /* Every to every, weight is linear fraction of distance between indexes (1 / distance) */\n  };\n\n/**\n * Simple generator of weights/edges for one4each() function. Probably you will change some of values by your intention after usage of this function\n * @param {Int} num_individuals number of individuals (number of indexes for wich will be weights generated) \n * @param {POLICY_EDMOND_WEIGHTS} policy policy for generating weights, see POLICY_EDMOND_WEIGHTS for description\n * @returns Array[NumberArray[3]] Array of edges in format [node_from, node_to, weight], node_from and node_to are indexes (starting from 0) of nodes, weight is wight of edge between this nodes\n*/\nfunction weightsGenerator_Edmonds(num_individuals, policy){\n    let edges = [];\n\n    switch (policy) {\n        case POLICY_EDMOND_WEIGHTS.E2E_EQUAL:\n            let comb_equal = combinations(num_individuals, 2);\n            comb_equal.forEach(nodes => {\n                edges.push([...nodes, 1]);\n            });\n            break;\n        case POLICY_EDMOND_WEIGHTS.E2E_SORTED_LINEAR:\n            let comb_sl = combinations(num_individuals, 2);\n            comb_sl.forEach(nodes => {\n                edges.push([...nodes, num_individuals - Math.abs(nodes[1] - nodes[0])]);\n            });\n            break;\n        case POLICY_EDMOND_WEIGHTS.E2E_SORTED_FRACTIONAL_LINEAR:\n            let comb_fl = combinations(num_individuals, 2);\n            comb_fl.forEach(nodes => {\n                edges.push([...nodes, 1/Math.abs(nodes[1] - nodes[0])]);\n            });\n            break;\n        default:\n          throw new NotSupportedAttributeValue(\"policy\", policy, \"use policy from POLICY_EDMOND_WEIGHTS\")\n    }\n    return edges;\n\n}\n\nfunction selectOneDimFromListByIds(list, ids){\n    let outter = ids.length;\n    let list_length = list.length;\n    let selected = Array(outter);\n    let id;\n    for (let i = 0; i < outter; i++) {\n        id = ids[i];\n        if (id >= list_length || id < 0) {\n            throw new NotMatchArguments(\"list\", list, \"ids\", ids, `value ${id} is out of range`);\n        }     \n        selected[i] = list[id];            \n    }   \n    return selected;\n}\n\nfunction selectTwoDimFromListByIds(list, ids){\n    let outter = ids.length;\n    let inner = ids[0].length\n    let list_length = list.length;\n    let selected = ArrayTwodim(outter, inner);\n    for (let j = 0; j < inner; j++) {\n        for (let i = 0; i < outter; i++) {    \n            id = ids[i][j];\n            if (id >= list_length || id < 0) {\n                throw new NotMatchArguments(\"list\", list, \"ids\", ids, `value ${id} is out of range`);\n            } \n            selected[i][j] = list[id];            \n        }        \n    }\n    return selected;\n}\n\nfunction indexesOfMaxInArray(array){\n    let indexes = [];\n\n    if (array.length == 0){\n        return indexes;\n    }\n\n    let actual_max = array[0];\n    \n    for (let index = 0; index < array.length; index++) {\n        const element = array[index];\n\n        if(element < actual_max){\n            continue;\n        }\n\n        if(element === actual_max){\n            indexes.push(index);\n            continue; \n        }\n        \n        /* higher than actual_max */\n        indexes = [];\n        indexes.push(index);\n        actual_max = element;\n        \n    }\n    return indexes;\n}\n\nfunction showListOfObjects(message=\"\", obj_list=[]){\n    console.log(message)\n    obj_list.forEach(obj => {\n        console.log(`\\t${obj}`);\n    });\n}\n\nmodule.exports = {\n    ArrayTwodim,\n    SetRange,\n    POLICY_EDMOND_WEIGHTS,\n    weightsGenerator_Edmonds,\n    selectOneDimFromListByIds,\n    selectTwoDimFromListByIds,\n    indexesOfMaxInArray,\n    showListOfObjects,\n};\n\n//# sourceURL=webpack://matchdraw/./src/Core/MD_Helpers.js?");

/***/ }),

/***/ "./src/Core/MD_MatchGenerator.js":
/*!***************************************!*\
  !*** ./src/Core/MD_MatchGenerator.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { NotSupportedAttributeValue } = __webpack_require__(/*! ./MD_Errors */ \"./src/Core/MD_Errors.js\");\nconst { combinations, maxWeightMatching } = __webpack_require__(/*! ./MD_Algorithms */ \"./src/Core/MD_Algorithms.js\");\nconst {\n    selectOneDimFromListByIds,\n    selectTwoDimFromListByIds,\n    SetRange, } = __webpack_require__(/*! ./MD_Helpers */ \"./src/Core/MD_Helpers.js\");\n\n/**\n * @typedef {Object} DrawResult\n * @property {Array[Array]} matches - Array of matches that are Array of competitors\n * @property {Array} singletons - Competitors not included in any match\n */\n\n/**\n * Generate matches so that every combination of competitors is included \n * @param {Array} individuals - Array of individuals that will compete in matches \n * @param {Integer} num default 2 - number of competitors in one match \n * @returns {DrawResult} - Result of draw\n */\nfunction every2every(individuals, num = 2){\n    let ids = combinations(individuals.length, num);\n    return {\n        matches : selectTwoDimFromListByIds(individuals, ids),\n        singletons : [], /* no singletons in every to every */\n    };\n}\n\n/**\n * Generate matches so that every Individuals occure in max one match. Maximize sum of edges (connections between individuals)\n * @param {Array} individuals - Array of individuals that will compete in matches\n * @param {Array[IntArray[0]]} weights - Array of edges with weights in format [indexOfIndividual_from, indexOfIndividual_to, weight]\n * @param {Int} num - default 2 (2 is only possible now) - number of competitors in one match \n * @param {Boolean} maximumMatches - if true -> prefer maximum count of matches over maximum sum of edges\n * @returns {DrawResult} - Result of draw\n */\nfunction one4each(individuals, weights, num = 2, maximumMatches=true){\n    if(num != 2){ throw new NotSupportedAttributeValue(\"num\", num, \"Only 2 competitors in match available at the moment.\")    }\n    const draw = maxWeightMatching(weights, maximumMatches);\n    \n    let ids = SetRange(individuals.length);\n    draw.matched_edges.forEach(matched_nodes => {\n        ids.delete(matched_nodes[0]);\n        ids.delete(matched_nodes[1]);\n    });\n    draw.nonmatched_nodes.forEach(non_matched_node => {\n        ids.delete(non_matched_node);\n    });\n\n    let nonmached_ids = draw.nonmatched_nodes;\n    ids.forEach(not_proccessed_node => {\n        nonmached_ids.push(not_proccessed_node);\n    });\n    nonmached_ids.sort();\n    return {\n        matches : selectTwoDimFromListByIds(individuals, draw.matched_edges),\n        singletons : selectOneDimFromListByIds(individuals, nonmached_ids),\n    }\n\n}\n\n\n\nmodule.exports = {every2every, one4each };\n\n//# sourceURL=webpack://matchdraw/./src/Core/MD_MatchGenerator.js?");

/***/ }),

/***/ "./src/Core/Retrieved/EdmondsBlossom.js":
/*!**********************************************!*\
  !*** ./src/Core/Retrieved/EdmondsBlossom.js ***!
  \**********************************************/
/***/ ((module) => {

eval("/*Converted to JS from Python by Matt Krick. Original: http://jorisvr.nl/maximummatching.html*/\n\n/**\n * \n * @param {Array[NumberArray[3]]} edges Array of edges in format [node_from, node_to, weight], , node_from and node_to are indexes (starting from 0) of nodes, weight is wight of edge between this nodes\n * @param {Boolean} maxCardinality if True, maximum possible count of edges has prirority over maximum sum of weigts \n * @returns {IntArray} index of array is index of node_from, value is index of node_to of matching edges, -1 if (index) node is not matched\n */\nfunction blossom (edges, maxCardinality = true) {\n    if (edges.length === 0) {\n      return edges;\n    }\n    var edmonds = new Edmonds(edges, maxCardinality);\n    return edmonds.maxWeightMatching();\n  \n  };\n  \n  var Edmonds = function (edges, maxCardinality) {\n    this.edges = edges;\n    this.maxCardinality = maxCardinality;\n    this.nEdge = edges.length;\n    this.init();\n  };\n  \n  Edmonds.prototype.maxWeightMatching = function () {\n    for (var t = 0; t < this.nVertex; t++) {\n      //console.log('DEBUG: STAGE ' + t);\n      this.label = filledArray(2 * this.nVertex, 0);\n      this.bestEdge = filledArray(2 * this.nVertex, -1);\n      this.blossomBestEdges = initArrArr(2 * this.nVertex);\n      this.allowEdge = filledArray(this.nEdge, false);\n      this.queue = [];\n      for (var v = 0; v < this.nVertex; v++) {\n        if (this.mate[v] === -1 && this.label[this.inBlossom[v]] === 0) {\n          this.assignLabel(v, 1, -1);\n        }\n      }\n      var augmented = false;\n      while (true) {\n        //console.log('DEBUG: SUBSTAGE');\n        while (this.queue.length > 0 && !augmented) {\n          v = this.queue.pop();\n          //console.log('DEBUG: POP ', 'v=' + v);\n          //console.assert(this.label[this.inBlossom[v]] == 1);\n          for (var ii = 0; ii < this.neighbend[v].length; ii++) {\n            var p = this.neighbend[v][ii];\n            var k = ~~(p / 2);\n            var w = this.endpoint[p];\n            if (this.inBlossom[v] === this.inBlossom[w]) continue;\n            if (!this.allowEdge[k]) {\n              var kSlack = this.slack(k);\n              if (kSlack <= 0) {\n                this.allowEdge[k] = true;\n              }\n            }\n            if (this.allowEdge[k]) {\n              if (this.label[this.inBlossom[w]] === 0) {\n                this.assignLabel(w, 2, p ^ 1);\n              } else if (this.label[this.inBlossom[w]] === 1) {\n                var base = this.scanBlossom(v, w);\n                if (base >= 0) {\n                  this.addBlossom(base, k);\n                } else {\n                  this.augmentMatching(k);\n                  augmented = true;\n                  break;\n                }\n              } else if (this.label[w] === 0) {\n                //console.assert(this.label[this.inBlossom[w]] === 2);\n                this.label[w] = 2;\n                this.labelEnd[w] = p ^ 1;\n              }\n            } else if (this.label[this.inBlossom[w]] === 1) {\n              var b = this.inBlossom[v];\n              if (this.bestEdge[b] === -1 || kSlack < this.slack(this.bestEdge[b])) {\n                this.bestEdge[b] = k;\n              }\n            } else if (this.label[w] === 0) {\n              if (this.bestEdge[w] === -1 || kSlack < this.slack(this.bestEdge[w])) {\n                this.bestEdge[w] = k;\n              }\n            }\n          }\n        }\n        if (augmented) break;\n        var deltaType = -1;\n        var delta = [];\n        var deltaEdge = [];\n        var deltaBlossom = [];\n        if (!this.maxCardinality) {\n          deltaType = 1;\n          delta = getMin(this.dualVar, 0, this.nVertex - 1);\n        }\n        for (v = 0; v < this.nVertex; v++) {\n          if (this.label[this.inBlossom[v]] === 0 && this.bestEdge[v] !== -1) {\n            var d = this.slack(this.bestEdge[v]);\n            if (deltaType === -1 || d < delta) {\n              delta = d;\n              deltaType = 2;\n              deltaEdge = this.bestEdge[v];\n            }\n          }\n        }\n        for (b = 0; b < 2 * this.nVertex; b++) {\n          if (this.blossomParent[b] === -1 && this.label[b] === 1 && this.bestEdge[b] !== -1) {\n            kSlack = this.slack(this.bestEdge[b]);\n            ////console.assert((kSlack % 2) == 0);\n            d = kSlack / 2;\n            if (deltaType === -1 || d < delta) {\n              delta = d;\n              deltaType = 3;\n              deltaEdge = this.bestEdge[b];\n            }\n          }\n        }\n        for (b = this.nVertex; b < this.nVertex * 2; b++) {\n          if (this.blossomBase[b] >= 0 && this.blossomParent[b] === -1 && this.label[b] === 2 && (deltaType === -1 || this.dualVar[b] < delta)) {\n            delta = this.dualVar[b];\n            deltaType = 4;\n            deltaBlossom = b;\n          }\n        }\n        if (deltaType === -1) {\n          //console.assert(this.maxCardinality);\n          deltaType = 1;\n          delta = Math.max(0, getMin(this.dualVar, 0, this.nVertex - 1));\n        }\n        for (v = 0; v < this.nVertex; v++) {\n          var curLabel = this.label[this.inBlossom[v]];\n          if (curLabel === 1) {\n            this.dualVar[v] -= delta;\n          } else if (curLabel === 2) {\n            this.dualVar[v] += delta;\n          }\n        }\n        for (b = this.nVertex; b < this.nVertex * 2; b++) {\n          if (this.blossomBase[b] >= 0 && this.blossomParent[b] === -1) {\n            if (this.label[b] === 1) {\n              this.dualVar[b] += delta;\n            } else if (this.label[b] === 2) {\n              this.dualVar[b] -= delta;\n            }\n          }\n        }\n        //console.log('DEBUG: deltaType', deltaType, ' delta: ', delta);\n        if (deltaType === 1) {\n          break;\n        } else if (deltaType === 2) {\n          this.allowEdge[deltaEdge] = true;\n          var i = this.edges[deltaEdge][0];\n          var j = this.edges[deltaEdge][1];\n          var wt = this.edges[deltaEdge][2];\n          if (this.label[this.inBlossom[i]] === 0) {\n            i = i ^ j;\n            j = j ^ i;\n            i = i ^ j;\n          }\n          //console.assert(this.label[this.inBlossom[i]] == 1);\n          this.queue.push(i);\n        } else if (deltaType === 3) {\n          this.allowEdge[deltaEdge] = true;\n          i = this.edges[deltaEdge][0];\n          j = this.edges[deltaEdge][1];\n          wt = this.edges[deltaEdge][2];\n          //console.assert(this.label[this.inBlossom[i]] == 1);\n          this.queue.push(i);\n        } else if (deltaType === 4) {\n          this.expandBlossom(deltaBlossom, false);\n        }\n      }\n      if (!augmented) break;\n      for (b = this.nVertex; b < this.nVertex * 2; b++) {\n        if (this.blossomParent[b] === -1 && this.blossomBase[b] >= 0 && this.label[b] === 1 && this.dualVar[b] === 0) {\n          this.expandBlossom(b, true);\n        }\n      }\n    }\n    for (v = 0; v < this.nVertex; v++) {\n      if (this.mate[v] >= 0) {\n        this.mate[v] = this.endpoint[this.mate[v]];\n      }\n    }\n    for (v = 0; v < this.nVertex; v++) {\n      //console.assert(this.mate[v] == -1 || this.mate[this.mate[v]] == v);\n    }\n    return this.mate;\n  };\n  \n  Edmonds.prototype.slack = function (k) {\n    var i = this.edges[k][0];\n    var j = this.edges[k][1];\n    var wt = this.edges[k][2];\n    return this.dualVar[i] + this.dualVar[j] - 2 * wt;\n  };\n  \n  Edmonds.prototype.blossomLeaves = function (b) {\n    if (b < this.nVertex) {\n      return [b];\n    }\n    var leaves = [];\n    var childList = this.blossomChilds[b];\n    for (var t = 0; t < childList.length; t++) {\n      if (childList[t] <= this.nVertex) {\n        leaves.push(childList[t]);\n      } else {\n        var leafList = this.blossomLeaves(childList[t]);\n        for (var v = 0; v < leafList.length; v++) {\n          leaves.push(leafList[v]);\n        }\n      }\n    }\n    return leaves;\n  };\n  \n  Edmonds.prototype.assignLabel = function (w, t, p) {\n    //console.log('DEBUG: assignLabel(' + w + ',' + t + ',' + p + '}');\n    var b = this.inBlossom[w];\n    //console.assert(this.label[w] === 0 && this.label[b] === 0);\n    this.label[w] = this.label[b] = t;\n    this.labelEnd[w] = this.labelEnd[b] = p;\n    this.bestEdge[w] = this.bestEdge[b] = -1;\n    if (t === 1) {\n      this.queue.push.apply(this.queue, this.blossomLeaves(b));\n      //console.log('DEBUG: PUSH ' + this.blossomLeaves(b).toString());\n    } else if (t === 2) {\n      var base = this.blossomBase[b];\n      //console.assert(this.mate[base] >= 0);\n      this.assignLabel(this.endpoint[this.mate[base]], 1, this.mate[base] ^ 1);\n    }\n  };\n  \n  Edmonds.prototype.scanBlossom = function (v, w) {\n    //console.log('DEBUG: scanBlossom(' + v + ',' + w + ')');\n    var path = [];\n    var base = -1;\n    while (v !== -1 || w !== -1) {\n      var b = this.inBlossom[v];\n      if ((this.label[b] & 4)) {\n        base = this.blossomBase[b];\n        break;\n      }\n      //console.assert(this.label[b] === 1);\n      path.push(b);\n      this.label[b] = 5;\n      //console.assert(this.labelEnd[b] === this.mate[this.blossomBase[b]]);\n      if (this.labelEnd[b] === -1) {\n        v = -1;\n      } else {\n        v = this.endpoint[this.labelEnd[b]];\n        b = this.inBlossom[v];\n        //console.assert(this.label[b] === 2);\n        //console.assert(this.labelEnd[b] >= 0);\n        v = this.endpoint[this.labelEnd[b]];\n      }\n      if (w !== -1) {\n        v = v ^ w;\n        w = w ^ v;\n        v = v ^ w;\n      }\n    }\n    for (var ii = 0; ii < path.length; ii++) {\n      b = path[ii];\n      this.label[b] = 1;\n    }\n    return base;\n  };\n  \n  Edmonds.prototype.addBlossom = function (base, k) {\n    var v = this.edges[k][0];\n    var w = this.edges[k][1];\n    var wt = this.edges[k][2];\n    var bb = this.inBlossom[base];\n    var bv = this.inBlossom[v];\n    var bw = this.inBlossom[w];\n    b = this.unusedBlossoms.pop();\n    //console.log('DEBUG: addBlossom(' + base + ',' + k + ')' + ' (v=' + v + ' w=' + w + ')' + ' -> ' + b);\n    this.blossomBase[b] = base;\n    this.blossomParent[b] = -1;\n    this.blossomParent[bb] = b;\n    path = this.blossomChilds[b] = [];\n    var endPs = this.blossomEndPs[b] = [];\n    while (bv !== bb) {\n      this.blossomParent[bv] = b;\n      path.push(bv);\n      endPs.push(this.labelEnd[bv]);\n      //console.assert(this.label[bv] === 2 || (this.label[bv] === 1 && this.labelEnd[bv] === this.mate[this.blossomBase[bv]]));\n      //console.assert(this.labelEnd[bv] >= 0);\n      v = this.endpoint[this.labelEnd[bv]];\n      bv = this.inBlossom[v];\n    }\n    path.push(bb);\n    path.reverse();\n    endPs.reverse();\n    endPs.push((2 * k));\n    while (bw !== bb) {\n      this.blossomParent[bw] = b;\n      path.push(bw);\n      endPs.push(this.labelEnd[bw] ^ 1);\n      //console.assert(this.label[bw] === 2 || (this.label[bw] === 1 && this.labelEnd[bw] === this.mate[this.blossomBase[bw]]));\n      //console.assert(this.labelEnd[bw] >= 0);\n      w = this.endpoint[this.labelEnd[bw]];\n      bw = this.inBlossom[w];\n    }\n    //console.assert(this.label[bb] === 1);\n    this.label[b] = 1;\n    this.labelEnd[b] = this.labelEnd[bb];\n    this.dualVar[b] = 0;\n    var leaves = this.blossomLeaves(b);\n    for (var ii = 0; ii < leaves.length; ii++) {\n      v = leaves[ii];\n      if (this.label[this.inBlossom[v]] === 2) {\n        this.queue.push(v);\n      }\n      this.inBlossom[v] = b;\n    }\n    var bestEdgeTo = filledArray(2 * this.nVertex, -1);\n    for (ii = 0; ii < path.length; ii++) {\n      bv = path[ii];\n      if (this.blossomBestEdges[bv].length === 0) {\n        var nbLists = [];\n        leaves = this.blossomLeaves(bv);\n        for (var x = 0; x < leaves.length; x++) {\n          v = leaves[x];\n          nbLists[x] = [];\n          for (var y = 0; y < this.neighbend[v].length; y++) {\n            var p = this.neighbend[v][y];\n            nbLists[x].push(~~(p / 2));\n          }\n        }\n      } else {\n        nbLists = [this.blossomBestEdges[bv]];\n      }\n      //console.log('DEBUG: nbLists ' + nbLists.toString());\n      for (x = 0; x < nbLists.length; x++) {\n        var nbList = nbLists[x];\n        for (y = 0; y < nbList.length; y++) {\n          k = nbList[y];\n          var i = this.edges[k][0];\n          var j = this.edges[k][1];\n          wt = this.edges[k][2];\n          if (this.inBlossom[j] === b) {\n            i = i ^ j;\n            j = j ^ i;\n            i = i ^ j;\n          }\n          var bj = this.inBlossom[j];\n          if (bj !== b && this.label[bj] === 1 && (bestEdgeTo[bj] === -1 || this.slack(k) < this.slack(bestEdgeTo[bj]))) {\n            bestEdgeTo[bj] = k;\n          }\n        }\n      }\n      this.blossomBestEdges[bv] = [];\n      this.bestEdge[bv] = -1;\n    }\n    var be = [];\n    for (ii = 0; ii < bestEdgeTo.length; ii++) {\n      k = bestEdgeTo[ii];\n      if (k !== -1) {\n        be.push(k);\n      }\n    }\n    this.blossomBestEdges[b] = be;\n    //console.log('DEBUG: blossomBestEdges[' + b + ']= ' + this.blossomBestEdges[b].toString());\n    this.bestEdge[b] = -1;\n    for (ii = 0; ii < this.blossomBestEdges[b].length; ii++) {\n      k = this.blossomBestEdges[b][ii];\n      if (this.bestEdge[b] === -1 || this.slack(k) < this.slack(this.bestEdge[b])) {\n        this.bestEdge[b] = k;\n      }\n    }\n    //console.log('DEBUG: blossomChilds[' + b + ']= ' + this.blossomChilds[b].toString());\n  };\n  \n  Edmonds.prototype.expandBlossom = function (b, endStage) {\n    //console.log('DEBUG: expandBlossom(' + b + ',' + endStage + ') ' + this.blossomChilds[b].toString());\n    for (var ii = 0; ii < this.blossomChilds[b].length; ii++) {\n      var s = this.blossomChilds[b][ii];\n      this.blossomParent[s] = -1;\n      if (s < this.nVertex) {\n        this.inBlossom[s] = s;\n      } else if (endStage && this.dualVar[s] === 0) {\n        this.expandBlossom(s, endStage);\n      } else {\n        var leaves = this.blossomLeaves(s);\n        for (var jj = 0; jj < leaves.length; jj++) {\n          v = leaves[jj];\n          this.inBlossom[v] = s;\n        }\n      }\n    }\n    if (!endStage && this.label[b] === 2) {\n      //console.assert(this.labelEnd[b] >= 0);\n      var entryChild = this.inBlossom[this.endpoint[this.labelEnd[b] ^ 1]];\n      var j = this.blossomChilds[b].indexOf(entryChild);\n      if ((j & 1)) {\n        j -= this.blossomChilds[b].length;\n        var jStep = 1;\n        var endpTrick = 0;\n      } else {\n        jStep = -1;\n        endpTrick = 1;\n      }\n      var p = this.labelEnd[b];\n      while (j !== 0) {\n        this.label[this.endpoint[p ^ 1]] = 0;\n        this.label[this.endpoint[pIndex(this.blossomEndPs[b], j - endpTrick) ^ endpTrick ^ 1]] = 0;\n        this.assignLabel(this.endpoint[p ^ 1], 2, p);\n        this.allowEdge[~~(pIndex(this.blossomEndPs[b], j - endpTrick) / 2)] = true;\n        j += jStep;\n        p = pIndex(this.blossomEndPs[b], j - endpTrick) ^ endpTrick;\n        this.allowEdge[~~(p / 2)] = true;\n        j += jStep;\n      }\n      var bv = pIndex(this.blossomChilds[b], j);\n      this.label[this.endpoint[p ^ 1]] = this.label[bv] = 2;\n  \n      this.labelEnd[this.endpoint[p ^ 1]] = this.labelEnd[bv] = p;\n      this.bestEdge[bv] = -1;\n      j += jStep;\n      while (pIndex(this.blossomChilds[b], j) !== entryChild) {\n        bv = pIndex(this.blossomChilds[b], j);\n        if (this.label[bv] === 1) {\n          j += jStep;\n          continue;\n        }\n        leaves = this.blossomLeaves(bv);\n        for (ii = 0; ii < leaves.length; ii++) {\n          v = leaves[ii];\n          if (this.label[v] !== 0) break;\n        }\n        if (this.label[v] !== 0) {\n          //console.assert(this.label[v] === 2);\n          //console.assert(this.inBlossom[v] === bv);\n          this.label[v] = 0;\n          this.label[this.endpoint[this.mate[this.blossomBase[bv]]]] = 0;\n          this.assignLabel(v, 2, this.labelEnd[v]);\n        }\n        j += jStep;\n      }\n    }\n    this.label[b] = this.labelEnd[b] = -1;\n    this.blossomEndPs[b] = this.blossomChilds[b] = [];\n    this.blossomBase[b] = -1;\n    this.blossomBestEdges[b] = [];\n    this.bestEdge[b] = -1;\n    this.unusedBlossoms.push(b);\n  };\n  \n  Edmonds.prototype.augmentBlossom = function (b, v) {\n    //console.log('DEBUG: augmentBlossom(' + b + ',' + v + ')');\n    var i, j;\n    var t = v;\n    while (this.blossomParent[t] !== b) {\n      t = this.blossomParent[t];\n    }\n    if (t > this.nVertex) {\n      this.augmentBlossom(t, v);\n    }\n    i = j = this.blossomChilds[b].indexOf(t);\n    if ((i & 1)) {\n      j -= this.blossomChilds[b].length;\n      var jStep = 1;\n      var endpTrick = 0;\n    } else {\n      jStep = -1;\n      endpTrick = 1;\n    }\n    while (j !== 0) {\n      j += jStep;\n      t = pIndex(this.blossomChilds[b], j);\n      var p = pIndex(this.blossomEndPs[b], j - endpTrick) ^ endpTrick;\n      if (t >= this.nVertex) {\n        this.augmentBlossom(t, this.endpoint[p]);\n      }\n      j += jStep;\n      t = pIndex(this.blossomChilds[b], j);\n      if (t >= this.nVertex) {\n        this.augmentBlossom(t, this.endpoint[p ^ 1]);\n      }\n      this.mate[this.endpoint[p]] = p ^ 1;\n      this.mate[this.endpoint[p ^ 1]] = p;\n    }\n    //console.log('DEBUG: PAIR ' + this.endpoint[p] + ' ' + this.endpoint[p^1] + '(k=' + ~~(p/2) + ')');\n    this.blossomChilds[b] = this.blossomChilds[b].slice(i).concat(this.blossomChilds[b].slice(0, i));\n    this.blossomEndPs[b] = this.blossomEndPs[b].slice(i).concat(this.blossomEndPs[b].slice(0, i));\n    this.blossomBase[b] = this.blossomBase[this.blossomChilds[b][0]];\n    //console.assert(this.blossomBase[b] === v);\n  };\n  \n  Edmonds.prototype.augmentMatching = function (k) {\n    var v = this.edges[k][0];\n    var w = this.edges[k][1];\n    //console.log('DEBUG: augmentMatching(' + k + ')' + ' (v=' + v + ' ' + 'w=' + w);\n    //console.log('DEBUG: PAIR ' + v + ' ' + w + '(k=' + k + ')');\n    for (var ii = 0; ii < 2; ii++) {\n      if (ii === 0) {\n        var s = v;\n        var p = 2 * k + 1;\n      } else {\n        s = w;\n        p = 2 * k;\n      }\n      while (true) {\n        var bs = this.inBlossom[s];\n        //console.assert(this.label[bs] === 1);\n        //console.assert(this.labelEnd[bs] === this.mate[this.blossomBase[bs]]);\n        if (bs >= this.nVertex) {\n          this.augmentBlossom(bs, s);\n        }\n        this.mate[s] = p;\n        if (this.labelEnd[bs] === -1) break;\n        var t = this.endpoint[this.labelEnd[bs]];\n        var bt = this.inBlossom[t];\n        //console.assert(this.label[bt] === 2);\n        //console.assert(this.labelEnd[bt] >= 0);\n        s = this.endpoint[this.labelEnd[bt]];\n        var j = this.endpoint[this.labelEnd[bt] ^ 1];\n        //console.assert(this.blossomBase[bt] === t);\n        if (bt >= this.nVertex) {\n          this.augmentBlossom(bt, j);\n        }\n        this.mate[j] = this.labelEnd[bt];\n        p = this.labelEnd[bt] ^ 1;\n        //console.log('DEBUG: PAIR ' + s + ' ' + t + '(k=' + ~~(p/2) + ')');\n  \n  \n      }\n    }\n  };\n  \n  \n  //INIT STUFF//\n  Edmonds.prototype.init = function () {\n    this.nVertexInit();\n    this.maxWeightInit();\n    this.endpointInit();\n    this.neighbendInit();\n    this.mate = filledArray(this.nVertex, -1);\n    this.label = filledArray(2 * this.nVertex, 0); //remove?\n    this.labelEnd = filledArray(2 * this.nVertex, -1);\n    this.inBlossomInit();\n    this.blossomParent = filledArray(2 * this.nVertex, -1);\n    this.blossomChilds = initArrArr(2 * this.nVertex);\n    this.blossomBaseInit();\n    this.blossomEndPs = initArrArr(2 * this.nVertex);\n    this.bestEdge = filledArray(2 * this.nVertex, -1); //remove?\n    this.blossomBestEdges = initArrArr(2 * this.nVertex); //remove?\n    this.unusedBlossomsInit();\n    this.dualVarInit();\n    this.allowEdge = filledArray(this.nEdge, false); //remove?\n    this.queue = []; //remove?\n  };\n  Edmonds.prototype.blossomBaseInit = function () {\n    var base = [];\n    for (var i = 0; i < this.nVertex; i++) {\n      base[i] = i;\n    }\n    var negs = filledArray(this.nVertex, -1);\n    this.blossomBase = base.concat(negs);\n  };\n  Edmonds.prototype.dualVarInit = function () {\n    var mw = filledArray(this.nVertex, this.maxWeight);\n    var zeros = filledArray(this.nVertex, 0);\n    this.dualVar = mw.concat(zeros);\n  };\n  Edmonds.prototype.unusedBlossomsInit = function () {\n    var i, unusedBlossoms = [];\n    for (i = this.nVertex; i < 2 * this.nVertex; i++) {\n      unusedBlossoms.push(i);\n    }\n    this.unusedBlossoms = unusedBlossoms;\n  };\n  Edmonds.prototype.inBlossomInit = function () {\n    var i, inBlossom = [];\n    for (i = 0; i < this.nVertex; i++) {\n      inBlossom[i] = i;\n    }\n    this.inBlossom = inBlossom;\n  };\n  Edmonds.prototype.neighbendInit = function () {\n    var k, i, j;\n    var neighbend = initArrArr(this.nVertex);\n    for (k = 0; k < this.nEdge; k++) {\n      i = this.edges[k][0];\n      j = this.edges[k][1];\n      neighbend[i].push(2 * k + 1);\n      neighbend[j].push(2 * k);\n    }\n    this.neighbend = neighbend;\n  };\n  Edmonds.prototype.endpointInit = function () {\n    var p;\n    var endpoint = [];\n    for (p = 0; p < 2 * this.nEdge; p++) {\n      endpoint[p] = this.edges[~~(p / 2)][p % 2];\n    }\n    this.endpoint = endpoint;\n  };\n  Edmonds.prototype.nVertexInit = function () {\n    var nVertex = 0;\n    for (var k = 0; k < this.nEdge; k++) {\n      var i = this.edges[k][0];\n      var j = this.edges[k][1];\n      if (i >= nVertex) nVertex = i + 1;\n      if (j >= nVertex) nVertex = j + 1;\n    }\n    this.nVertex = nVertex;\n  };\n  Edmonds.prototype.maxWeightInit = function () {\n    var maxWeight = 0;\n    for (var k = 0; k < this.nEdge; k++) {\n      var weight = this.edges[k][2];\n      if (weight > maxWeight) {\n        maxWeight = weight;\n      }\n    }\n    this.maxWeight = maxWeight;\n  };\n  \n  //HELPERS//\n  function filledArray(len, fill) {\n    var i, newArray = [];\n    for (i = 0; i < len; i++) {\n      newArray[i] = fill;\n    }\n    return newArray;\n  }\n  \n  function initArrArr(len) {\n    var arr = [];\n    for (var i = 0; i < len; i++) {\n      arr[i] = [];\n    }\n    return arr;\n  }\n  \n  function getMin(arr, start, end) {\n    var min = Infinity;\n    for (var i = start; i <= end; i++) {\n      if (arr[i] < min) {\n        min = arr[i];\n      }\n    }\n    return min;\n  }\n  \n  function pIndex(arr, idx) {\n    //if idx is negative, go from the back\n    return idx < 0 ? arr[arr.length + idx] : arr[idx];\n  }\n\n  module.exports = {blossom};\n\n//# sourceURL=webpack://matchdraw/./src/Core/Retrieved/EdmondsBlossom.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Options = __webpack_require__(/*! ./Competition/MD_Options */ \"./src/Competition/MD_Options.js\");\nconst Swiss_Radon = __webpack_require__(/*! ./Competition/MD_Swiss_Radon */ \"./src/Competition/MD_Swiss_Radon.js\");\n\nconsole.log(\"See examples in showroom directory for usage example.\");\n\nmodule.exports = {Options, Swiss_Radon};\n\n//# sourceURL=webpack://matchdraw/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;